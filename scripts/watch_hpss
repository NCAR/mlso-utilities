#!/usr/bin/env python

import argparse
import collections
import datetime
import glob
import logging
import os
import signal
import subprocess
import time


# locations

#QUEUE_ROOT = '/hao/mlsodata3/Data/HPSS-Queue'
QUEUE_ROOT = '/home/mgalloy/hpss-queue'
#HPSS_ROOT  = '/CORDYN'
#HPSS_ROOT  = '/home/mgalloy'
HPSS_ROOT  = '/home/mgalloy/hpss-root'
HSI_ROOT   = '/opt/local/hpss'

# logging

LOG_ROOT = '/home/mgalloy/hpss-logs'
LOG_FMT  = '%(asctime)s %(levelname)s: %(module)s: %(message)s'
DATE_FMT = '%Y-%d-%m %H:%M:%S'

# time between polling, in seconds
#POLL_DELAY = 60.0 * 5
POLL_DELAY = 15.0

# nicer names
instrument_names = {'kcor': 'KCor', 'comp': 'CoMP'}
signal_names = collections.defaultdict(str, {signal.SIGINT:  'SIGINT',
                                             signal.SIGTERM: 'SIGTERM'})


class SignalWatcher:
    '''Register for SIGINT/SIGTERM to allow user to exit when they are ready.

       Typical usage would be to create a GracefulKiller object when the
       application starts and then checked during some loop:

         killer = GracefulKiller()
         while True:
             # do some stuff
             if killer.is_terminated:
                 break
    '''

    def __init__(self):
        self.is_terminated = False
        self.signum = 0
        signal.signal(signal.SIGINT, self.handle_signal)
        signal.signal(signal.SIGTERM, self.handle_signal)

    def handle_signal(self, signum, frame):
        self.is_terminated = True
        self.signum = signum


class DirectoryLock:

    def __init__(self, dir):
        self.dir = dir
        self.have_lock = False

    @property
    def lock_file(self):
        return(os.path.join(self.dir, '.lock'))

    def __enter__(self):
        if os.path.exists(self.lock_file):
            self.have_lock = False
        else:
            self.have_lock = True
            open(self.lock_file, 'w').close()
            logging.info('locking %s' % self.dir)


    def __exit__(self, exc_type, exc_value, traceback):
        if self.have_lock:
            os.remove(self.lock_file)
            have_lock = False
            logging.info('release lock on %s' % self.dir)


class Local:

    def __init__(self):
        pass

    def __enter__(self):
        '''Open connection to local system'''
        logging.info('opened connection to local system')
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        '''Close connection to local system'''
        logging.info('closed connection to local system')

    def put(self, src, dst):
        logging.info('putting %s -> %s' % (src, dst))
        cmd = ['cp', src, dst]
        process = subprocess.Popen(cmd,
                                   stdout=subprocess.PIPE,
                                   stderr=subprocess.STDOUT)
        output, _ = process.communicate()
        process.wait()

        if process.returncode != 0:
            logging.error('problem with cmd: "%s"' % ' '.join(cmd))
            logging.error(output)
            raise IOError('problem putting %s -> %s' % (src, dst))

    def file_size(self, filename):
        '''Return file size of given filename in bytes.'''
        cmd = ['ls', '-l', filename]
        process = subprocess.Popen(cmd,
                                   stdout=subprocess.PIPE,
                                   stderr=subprocess.STDOUT)
        output, _ = process.communicate()
        process.wait()

        if process.returncode != 0:
            logging.error('problem with cmd: "%s"' % ' '.join(cmd))
            logging.error(output)
            raise IOError('problem finding size of %s' % filename)

        return(int(output.split()[4]))


class HPSS:

    def __init__(self):
        pass

    def __enter__(self):
        '''Open connection to HPSS'''
        logging.info('opened connection to HPSS')
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        '''Close connection to HPSS'''
        logging.info('closed connection to HPSS')

    def put(self, src, dst):
        logging.info('putting %s -> %s' % (src, dst))
        hsi_cmd = ['%s/bin/hsi' % HSI_ROOT, '-q', '-P', 'cput', src, ':', dst]
        process = subprocess.Popen(hsi_cmd,
                                   stdout=subprocess.PIPE,
                                   stderr=subprocess.STDOUT)
        output, _ = process.communicate()
        process.wait()

        if process.returncode != 0:
            logging.error('problem with cmd: "%s"' % ' '.join(hsi_cmd))
            logging.error(output)
            raise IOError('problem putting %s -> %s' % (src, dst))

    def file_size(self, filename):
        '''Return file size of given filename in bytes.'''
        hsi_cmd = ['%s/bin/hsi' % HSI_ROOT, '-q', '-P', 'ls', '-P', filename]
        process = subprocess.Popen(hsi_cmd,
                                   stdout=subprocess.PIPE,
                                   stderr=subprocess.STDOUT)
        output, _ = process.communicate()
        process.wait()

        if process.returncode != 0:
            logging.error('problem with cmd: "%s"' % ' '.join(hsi_cmd))
            logging.error(output)
            raise IOError('problem finding size of %s' % filename)

        return(int(output.split()[2]))


if __name__ == '__main__':
    name = 'Watch for files to send to HPSS'
    parser = argparse.ArgumentParser(description=name)
    parser.add_argument('instrument', type=str, nargs=1,
                        help='instrument to watch for, i.e., kcor, comp, etc.')
    args = parser.parse_args()

    instrument = args.instrument[0].lower()

    today = datetime.date.today()
    year = today.strftime('%Y')

    log_basename = '%s.hpss.%s.log' % (today.strftime('%Y%m%d'), instrument)
    log_filename = os.path.join(LOG_ROOT, log_basename)

    logging.basicConfig(filename=log_filename,
                        format=LOG_FMT, datefmt=DATE_FMT,
                        level=logging.DEBUG)

    with Local() as h:
        src_root = os.path.join(QUEUE_ROOT, instrument_names[instrument])
        dst_root = os.path.join(HPSS_ROOT, instrument_names[instrument].upper(), year)
        signal_watcher = SignalWatcher()

        while True:
            with DirectoryLock(src_root) as dl:
                logging.info('checking %s' % src_root)

                for src_filename in glob.glob(os.path.join(src_root, '*')):
                    basename = os.path.basename(src_filename)
                    local_size = os.path.getsize(src_filename)

                    dst_filename = os.path.join(dst_root, basename)

                    try:
                        h.put(src_filename, dst_filename)
                        hpss_size = h.file_size(dst_filename)

                        if local_size != hpss_size:
                            logging.warning('size on HPSS (%d) != local size (%d)' % (hpss_size, local_size))
                            break
                    except IOError as e:
                        logging.warning(e)
                        break

                    logging.debug('removing %s from queue dir' % basename)
                    os.remove(src_filename)

                    if signal_watcher.is_terminated: break

                if signal_watcher.is_terminated:
                    break
                else:
                    time.sleep(POLL_DELAY)

        logging.info('exited from %s' % signal_names[signal_watcher.signum])
        logging.shutdown()
